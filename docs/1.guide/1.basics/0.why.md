---
icon: clarity:rack-server-outline-alerted
---

# Why srvx?

> Why does srx exist and why would you want to use it?

### Making the Case

When creating a new HTTP server with [Node.js][Node], you must either use the [node:http](https://nodejs.org/api/http.html) module or a library derived from it.

**Ex.** - Node.js HTTP server ([learn more](https://nodejs.org/en/learn/getting-started/introduction-to-nodejs)):

```js
import { createServer } from "node:http";

createServer((req, res) => {
  res.end("Hello, Node.js!");
}).listen(3000);
```

Whenever a new request is received, the request event is called with two Node objects:

- Request (conventionally `req`), which is of the type [node:IncomingMessage][IncomingMessage], and passed in as the first argument of the event and enables access to the HTTP request details.
- Response (conventionally `res`), which is of the type [node:ServerResponse][ServerResponse], and passed in as the second argument of the event and allows preparing and sending of an HTTP response.

Other popular server frameworks such as [Express][Express] and [Fastify][Fastify] also leverage the Node.js server API in their internals.

:read-more{to="/guide/advanced/node" title="Node.js support"}

With the recent arrival of new JavaScript server runtimes, [Deno][Deno] and [Bun][Bun], we've seen them implement a different approach when defining a server, which bears more in common with the web [Fetch][Fetch] API.

**Ex.** - Deno HTTP server ([learn more](https://docs.deno.com/api/deno/~/Deno.serve)):

```js
Deno.serve({ port: 3000 }, (_req, info) => new Response("Hello, Deno!"));
```

**Ex.** - Bun HTTP server ([learn more](https://bun.sh/docs/api/http)):

```js
Bun.serve({ port: 3000, fetch: (req) => new Response("Hello, Bun!") });
```

As you may have noticed, there is a difference between Node.js and Deno/Bun. With the latter two, the incoming request is a web [Request][Request] object and the server response is a web [Response][Response] object.
Accessing headers, the request path, and preparing the response is completely different from Node's implementation.

And while Deno and Bun servers are both based on web standards, there are differences between them as well. Some examples: how they provide options, server lifecycles, and accessing request info such as the client IP (which is not part of the web Request standard).

**Thus, the main use-case of this library is for tools and frameworks that wish to be runtime agnostic.**
Instead of depending on idiosyncratic runtime APIs, we can use **srvx** as a standardized server layer, and help drive the JavaScript ecosystem towards web standards and greater consistency!

### How is it Different?

You might ask, what is the difference between **srvx** and these other HTTP frameworks?

**srvx** provides a simple, low-level, and universal API, very similar to Deno and Bun's. It comes with **no conventions**, utilities, or router, and in most cases, introduces no overhead.

The core of **srvx** was extracted from an early development branch of the v2 for the [h3](https://h3.dev/) server framework and released to the broader ecosystem to encourage the adoption of web platform standards without enforcing its own conventions.

[Node]: https://nodejs.org/
[Deno]: https://deno.com/
[Bun]: https://bun.sh/
[Express]: https://expressjs.com/
[Fastify]: https://fastify.dev/
[Fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[Request]: https://developer.mozilla.org/en-US/docs/Web/API/Request
[Response]: https://developer.mozilla.org/en-US/docs/Web/API/Response
[IncomingMessage]: https://nodejs.org/api/http.html#http_class_http_incomingmessage
[ServerResponse]: https://nodejs.org/api/http.html#http_class_http_serverresponse
