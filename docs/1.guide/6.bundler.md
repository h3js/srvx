---
icon: clarity:bundle-line
---

# Bundler usage

Typically `srvx` is to be imported like this.

```js
import { serve } from "srvx";
```

The import above automatically resolves the the correct entrypoint for each runtime. Node.js, Deno and Bun use [ESM conditions](https://nodejs.org/api/esm.html#resolution-algorithm-specification) to resolve the correct entrypoint.

## Without bundling

If you are directly using `srvx` in your project without bundling or have `srvx` as an external, non-bundled dependency, it should work as expected.

## Bundler usage

If srvx is being bundled (e.g. by [Rollup](https://rollupjs.org/) or [esbuild](https://esbuild.github.io/)),
the bundler also has to run the ESM resolution algorithm during bundling.
This means the `srvx` in the bundle will only work with one specific runtime (usually Node.js).


### External dependency

The simplest way to avoid this is to set `srvx` as an [external dependency](https://rollupjs.org/configuration-options/#external) in your bundler.

::code-group

```js [Rollup]
export default {
    //...
    external: ["srvx"],
};
```

```ts [esbuild]
import { build } from "esbuild";

await build({
    //...
    external: ["srvx"] // Add this
});
```

```bash [esbuild (CLI)]
esbuild main.ts \
    # ...
    --external:srvx # Add this
```

::

By doing this, srvx won't be included in the final bundle, it needs to be available at runtime.

### Conditions

Another approach is to set the ESM condition manually at bundle time.

::code-group

```js [Rollup]
import resolve from '@rollup/plugin-node-resolve'

export default {
    //...
    plugins: [
        resolve({
            preferBuiltins: true,
            conditions: ["node"] // or "deno", "bun", "workerd", etc.
        })
    ],
}
```

```ts [esbuild]
import { build } from "esbuild";

await build({
    //...
    conditions: ["node"] // or "deno", "bun", "workerd", etc.
});
```

```bash [esbuild (CLI)]
esbuild main.ts \
    # ...
    --conditions:node # or deno, bun, workerd, etc.
```

::

By doing this, the bundler will resolve the correct version on srvx for your runtime.

#### Determine automatically

You can also use [std-env](https://github.com/unjs/std-env/) to determine the runtime automatically.
This way, the resolved version of srvx will match the runtime used to make the bundle.

Please note that this still means your final bundle will only work in the same runtime used to make the bundle.
(in Node if built with `node bundle.mjs`, in Deno if built with `deno run bundle.mjs`, etc.)

```ts [bundle.mjs]
import { build } from "esbuild";
import { runtime } from "std-env";

await build({
    //...
    conditions: [runtime]
});
```
